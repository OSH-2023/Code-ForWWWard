
# ROS2基于DCA技术优化实时性的可行性报告

## 目录

## 小组成员

* 王润泽

* 王道宇

* 封霁芩

* 陈应豪

* 王昱
## 项目背景：ROS2通信框架的实时性问题
### 实时性和低延迟通信的要求
//TODO: wdy
### ROS2在Linux系统上实时性的瓶颈
* `Linux`**内核的实时性不足**：`Linux`内核的调度机制并不是针对实时性的，这使得`Linux`无法提供完全实时的响应

### ROS2通信框架的性能瓶颈
* `ROS2`使用通用的通信框架，它的设计并不是专门为实时性而优化的。`ROS2`使用`DDS`作为通信协议，`DDS`是一种高度灵活的通信协议，但其对实时性能的支持并不足够强大

* **CPU资源占用**：需要占用CPU资源进行消息的序列化、反序列化、传输等操作，如果CPU资源占用过高，则会影响实时性能
* **内存管理**：涉及到内存的动态分配和释放，如果内存管理不当，会导致内存碎片问题，从而影响实时性能

> 因此我们需要引入DCA技术来大大提高ROS2的实时性

## 理论支撑

### ROS2通信框架及其应用
- **Publish-Subscribe(1)**
  - ***Pub***通过Topic向***Sub***传递数据
  - 该机制常用于连续数据流，数据可以在任何时间独立于任何***Pub***/***Sub***发布和订阅
- **Service-Client(2)**
  - ***Client***向***Server***发出请求，***Server***执行任务后将response返回给***Client***
  - 该机制常用于快速终止的远程过程调用，不应该用于运行时间较长的进程，特别是，如果发生特殊情况，可能需要抢占的过程。并且它们永远不应改变或依赖于状态，以避免对其他节点产生不必要的副作用
- **Actions(3)**
  - 基于***Service-Client***，在执行任务时产生了多次Fback
  - 该机制常用于移动机器人或**运行更长时间但在执行过程中提供反馈的任何离散行为**

![](image/ROS2通信.png)

### NIC与CPU交互模式

网卡(Network Interface Card，简称NIC)，也称网络适配器，是电脑与局域网相互连接的设备。

#### Ring-based Model

初始化时，处理器在内存中为传入和传出的数据包分配缓冲区。它在描述符中记录缓冲区的属性(例如，它们的基址和长度)，并将这些描述符存储在两个环中，一个用于发送(TX)，另一个用于接收(RX)。

![](./research%20by%20fjq/src/ring-based-model.png)

- 当数据包到达时：
  - S2:NIC读取环头指向的描述符以获取空缓冲区，将数据包内容写入缓冲区，并更新描述符以记录数据包的属性。
  - S3:向处理器发送中断，以通知数据包的到达。
  - S4:处理器通过中断或对尾指针所指向的描述符进行忙轮询来得到通知。它给出一个新的描述符，指向RX环的空缓冲区，移动尾指针，并将接收到的缓冲区移交给应用程序。
- 发送数据包时：
  - S5: 一旦处理程序完成，驱动程序在head指针指向的空TX描述符上申请缓冲区，并移动指针提示NIC
  - S6: NIC读取TX描述符，获取缓冲区，并将其内容发送到线路，移动TX尾以指示数据包发送完成
  - S7: 驱动定期检查TX环以回收已发送的缓冲区

NIC与处理器有多种交换数据信息的模式，包括中断、内存映射IO (MMIO)和直接内存访问(DMA)。
### igb

//TODO:fjq

### DMA与DCA技术介绍

 DMA (Direct Memory Access)技术，其基本思想是外设和 RAM 之间开辟直接的数据传输通路。一般情况下，总线所有的工作周期（总线周期）都用于 CPU 执行程序。DMA 控制就是当外设完成数据 I/O 的准备工作之后，会占用总线的一个工作周期，和 RAM 直接交换数据。这个周期之后，CPU又继续控制总线执行原程序。如此反复的，直到整个数据块的数据全部传输完毕，从而解放了CPU。

 DCA (Direct Cache Access)技术通过将目标从内存更改为处理器缓存来改进DMA。这有助于减少I/O延迟，并通过防止数据在内存总线上传输两次来节省内存带宽。DCA是一个通用术语，其实现方式各异。
#### DMA

- **总线控制**：CPU和外设再写入系统内存时，可能发生总线争用，有以下三种方式处理冲突：
  - **突发模式（Burst mode）**：在突发模式下，整个数据块以一个连续的序列传输。一旦 DMA 控制器被 CPU 授予对系统总线的访问权限，它就会在将系统总线的控制权交还给 CPU 之前传输数据块中的所有字节数据，但会使 CPU 在相对较长的时间内处于非活动状态。
  - **循环窃取模式（Cycle stealing mode）**：循环窃取模式用于 CPU 不应在突发传输模式所需的时间长度内被禁用的系统。在循环窃取模式下，通过不断获得和释放对系统总线的控制，DMA 控制器实质上交织了指令和数据传输。CPU 处理一条指令，然后 DMA 控制器传输一个数据值，依此类推。数据传输速度没有那么快，但 CPU 的空闲时间没有突发模式那么长。
  - **透明模式（Transparent mode）**：透明模式需要最多的时间来传输数据块，但就整体系统性能而言，它也是最有效的模式。在透明模式下，DMA 控制器仅在 CPU 执行不使用系统总线的操作时传输数据。透明模式的主要优点是 CPU 永远不会停止执行其程序并且 DMA 传输在时间上是免费的，而缺点是硬件需要确定 CPU 何时不使用系统总线，这可能很复杂.

* **缓存一致性（Cache coherency）**

![](https://camo.githubusercontent.com/b8a097d124c158b98cfb4b3471ef27a08688aaacecb879a4c85eed64708bcf95/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f7468756d622f342f34392f43616368655f696e636f686572656e63655f77726974652e7376672f35353970782d43616368655f696e636f686572656e63655f77726974652e7376672e706e67)

> 当设备向内存写入数据时，由于CPU可能会将数据缓存在L1、L2、L3缓存中，设备无法直接访问缓存，因此会向内存中写入数据，但是缓存中的数据可能已经发生了改变。同样地，当设备从内存中读取数据时，由于CPU可能将数据缓存在缓存中，设备读取的数据可能是缓存中的数据，而不是最新的数据。这就是所谓的缓存一致性问题。 为了解决缓存一致性问题，现代的CPU和设备通常采用了一些技术来保证缓存一致性。例如，CPU可以使用cache一致性协议（如MESI）来保证多个缓存之间的一致性。当设备向内存写入数据时，缓存中对应的数据会被标记为“失效”，即无效状态，这样在其他缓存中的数据就会被清除。当CPU访问该内存地址时，会从内存中重新读取最新的数据，从而保证缓存一致性。 DMA控制器通常也采用类似的机制来保证缓存一致性。在进行DMA数据传输时，DMA控制器会通知CPU缓存该内存地址中的数据已经失效，以便CPU在下次访问该内存地址时能够从内存中读取最新的数据，而不是从缓存中读取旧数据。一些现代的DMA控制器甚至支持cache一致性协议，从而可以直接与CPU的缓存进行通信，提高了系统的性能和可靠性。

>  [MESI协议](https://zhuanlan.zhihu.com/p/123926004) 所有cache与内存，cache与cache（cache之间也会有数据传输）之间的传输都发生在一条共享的总线上，而所有的cpu都能看到这条总线，同一个指令周期中，只有一个cache可以读写内存，所有的内存访问都要经过仲裁（arbitrate）。

>  MESI协议的思想是，cahce不但与内存通信时和总线打交道，而且它会不停地窥探总线上发生的数据交换，跟踪其他cache在做什么。所以当一个cache代表它所属的cpu去读写内存时，其它cpu都会得到通知，它们以此来使自己的cache保持同步。

- **DMA传输模式**
  - 外设到存储器
  - 存储器到外设
  - 存储器到存储器

 //TODO:DMA和DCA有什么不同，为什么要使用DCA
#### DCA的优势
* `DCA`的优势
  
  * `DCA`显著减少接收密集型网络I/O的**内存延迟和内存带宽**
  * `DCA`可以减少很大一部分的`cache misses`
  * `DCA`技术通过将远程内存数据直接预取到处理器的缓存中，避免了传统访问模式下频繁的内存访问，从而减少了CPU与内存之间的数据传输和访问延迟，提高了**系统的吞吐量和响应速度**。与传统`DMA（Direct Memory Access，直接内存访问）`技术相比，`DCA`技术可以实现更高的效率和性能，同时还能降低系统的负载和功耗

* 通过直接访问CPU缓存中的数据，减少CPU与内存之间的数据传输时间，从而减少了CPU资源的占用。

## 操作系统内核配置
> 经过查询，我们发现了`Linux kernel	6.2.11 stable version`支持`DCA`的选项

![](image/linux_kernel_dca.png)

## 相关代码与实现

### 调用DCA的基本步骤及相关的头文件

>  [dca.h头文件](https://github.com/torvalds/linux/blob/master/include/linux/dca.h)
> 
>  下面是一些重要的函数、结构体

```cpp
//注册一个DCA提供者的函数
int register_dca_provider(struct dca_provider *dca, struct device *dev);
//注销一个DCA提供者的函数
void unregister_dca_provider(struct dca_provider *dca, struct device *dev);
//结构体
struct dca_provider {
    struct list_head    node;
    const struct dca_ops    *ops;
    struct device         *cd;
    int             id;
};

struct dca_domain {
    struct list_head    node;
    struct list_head    dca_providers;
    struct pci_bus        *pci_rc;
};

struct dca_ops {
    int    (*add_requester)    (struct dca_provider *, struct device *);
    int    (*remove_requester) (struct dca_provider *, struct device *);
    u8    (*get_tag)        (struct dca_provider *, struct device *,
                     int cpu);
    int    (*dev_managed)      (struct dca_provider *, struct device *);
};
//添加一个DCA请求的函数
int dca_add_requester(struct device *dev);
//删除一个DCA请求的函数
int dca_remove_requester(struct device *dev);
```

* **引入头文件**：通常需要引入相关的系统或库文件的头文件，以便在代码中调用相应的函数或接口。例如，在Linux系统中，可以引入**<linux/dca.h>头文件**来使用DCA相关的函数和宏定义。

* **初始化DCA**：需要在程序启动时进行DCA的初始化，以确保DCA功能可以正常使用。通常需要调用相关的函数或接口，例如在Linux系统中，可以使用**dca_sysfs_init()函数**来初始化DCA。

* **配置DCA**：需要根据具体的应用场景和数据访问模式来配置DCA，例如设置预取的数据大小和预取的地址等参数。通常需要使用相应的函数或接口来进行配置，例如在Linux系统中，可以使用**dca3_config()函数**来配置DCA。

* **调用DCA**：在程序运行时，可以使用相应的函数或接口来调用DCA功能，以实现预取数据到缓存中。例如在Linux系统中，可以使用**dca3_get_tag()函数**来执行DCA操作。

## 硬件支持

### 使用Intel的原因

据调研，目前Intel是唯一提供带有DCA支持的商用处理器的供应商
(补充：其他供应商)

### IOAT-DDIO
//TODO:(找官网资料)wrz

## 实验与评估方法

#### 实验步骤

> 1. 挑选适合的linux版本，要求支持DCA。编译内核，勾选相应的DCA支持模块。
> 2. 安装ROS库，用C/C++调用相关库函数实现节点间通信
> 3. 使用智能网卡，实现数据通信的DMA
> 4. 引用`linux/dca.h`等库函数，实现对本地/传输数据0拷贝进入cache，实现DCA
> 5. 找一个i/o密集型，单次处理数据量小的任务，通过系统给出的函数进行计时，测试使用了相关技术前后的时间差异

- 验证方法
  - 对比程序自己编写
  - 数据传输：使用ROS相关的库函数，使用linux DCA库，放进cache计算，IO密集型。
  - 正常的数据传输，用clk粗略计时，比较其他的方案
## 结论

## 参考文献

- [Understanding I/O Direct Cache Access Performance for End Host Networking]( https://dl.acm.org/doi/10.1145/3508042)

***

# 下面是可行性报告的框架

## 1. 背景介绍

- ROS2通信框架及其应用
- 实时性和低延迟通信的需求
- DCA技术介绍及其优势
- NIC与CPU交互

## 2. ROS2通信框架中存在的性能瓶颈

- 运行在Linux上降低了实时性
- ROS2通信框架中可能出现的性能瓶颈
- ROS2通信框架中性能瓶颈与实时性的关系

## 3. DCA技术在ROS2中的应用

- 为什么只能是intel不能是amd

- DCA技术与ROS2通信框架的结合

- DCA技术对ROS2实时性的影响

- DCA技术在ROS2通信中的优化效果
  
  ## 4. 代码实现

- C头文件

- 相关函数介绍 

## 5. 硬件情况

## 6. 实验与评估方法

- 

可能使用的评估方案

## 7. 结论

- 主要结论

## 8. 参考文献

> > > > > > > e7377a8b4a6659e87e5864bf93cfac4d15a33e7e
